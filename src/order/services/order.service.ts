import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { OrderRepository } from '../repositories/order.repository';
import { Order } from '../entities/order.entity';
import { CreateOrderDto } from '../dto/create-order.dto';
import { UpdateOrderDto } from '../dto/update-order.dto';

@Injectable()
export class OrderService {
  constructor(private readonly orderRepository: OrderRepository) {}

  async create(buyerId: string, createDto: CreateOrderDto): Promise<Order> {
    const order = new Order({
      id: '', // will be generated by Prisma
      buyerId,
      shopId: createDto.shopId,
      totalAmount: createDto.totalAmount,
      currency: createDto.currency,
      paymentStatus: createDto.paymentStatus,
      paymentMethod: createDto.paymentMethod,
      orderStatus: createDto.orderStatus,
      items: [],
      eventRecords: [],
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    return this.orderRepository.create(order);
  }

  async findOne(id: string, buyerId?: string): Promise<Order> {
    const order = await this.orderRepository.findOne(id);
    if (!order) {
      throw new NotFoundException('Order not found');
    }
    if (buyerId && order.buyerId !== buyerId) {
      throw new ForbiddenException('Order does not belong to this buyer');
    }
    return order;
  }

  async findByBuyerId(buyerId: string): Promise<Order[]> {
    return this.orderRepository.findByBuyerId(buyerId);
  }

  async update(
    orderId: string,
    buyerId: string,
    updateDto: UpdateOrderDto,
  ): Promise<Order> {
    const existingOrder = await this.findOne(orderId, buyerId);

    // merge changes
    const updatedOrder = new Order({
      ...existingOrder,
      ...updateDto,
      updatedAt: new Date(),
    });

    return this.orderRepository.update(updatedOrder);
  }

  async remove(id: string, buyerId: string): Promise<Order> {
    const order = await this.findOne(id, buyerId);
    return this.orderRepository.remove(order.id);
  }
}
